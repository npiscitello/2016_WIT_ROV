surface -> rov Command Format: JSON
Command Structure: {"action":"<command>"[,"data":{<data>}]}

rov -> surface Response Format: JSON
Response Structure: {"success":<bool>, "err":<error>, "data":{<data>}}

ROV Command Library:
  get_time: returns ROV local time
  get_mem_usage: returns ROV memory usage stats
  get_cpu_usage: returns ROV processor load average
  ping: simple ping; do nothing, return nothing 
  echo: repeat back 'data' field from surface, if there was one
  // hmc stuff //
  hmc_init: initializes a new hmc object on i2c bus 1 at address 0x19
  hmc_get_accel: returns hmc's accelerometer data in an object: {"ax":[x-value], "ay":[y-value], "az":[z-value]}
  hmc_get_mag: returns hmc's magnetometer data in an object: {"mx":[x-value], "my":[y-value], "mz":[z-value]}
  // pca stuff //
  pca_init: initializes a new pca object on i2c bus 1 at address 0x40
  pca_set_pulseRange: usage: {action:pca_set_dutyCycle, chan:[channel], stepOn:[on step], stepOff:[off step]}
  	chan = pca channel to output to
  	stepOn = turn on on this step
  	stepOff turn off on this step
  pca_set_dutyCycle: usage: {action:pca_set_dutyCycle, chan:[channel], val:[value]}
  	chan = pca channel to output to
  	val = set duty dudy cycle on channel chan to this (range: 0-1, 25% would be 0.25)


surfaceserver acts as a translator for the webpage - raw i/o goes between page and 
server, server sends structured data to ROV

special events (e.g. button clicks) are sent on their own in the following format:
  {"spevent":true, "data":{"buttonID": <what button was pressed>}}

control paradigm: surface server stores all data. It pushes it's copy
of relevant data to the ROV and webpage, which both respond with data updates. The
surfaceserver updates its local info and the page and ROV are updated on the next
data push. This is done asyncronously (updates are pushed to the page as they come up
from the ROV and updates get pushed to the ROV as they arrive from the page).
Connectivity is verified by periodic hearbeat packets to the page and the ROV.

surface -> webpage Comms Format: JSON (output data to be displayed) (can be any combination of valid data values)
Structure: {"heading":<heading>, "depth":<depth>, "temperature":<temp>, etc...}

webpage -> surface Comms Format: JSON (input data to be parsed and acted upon)
Structure: {"spevent":false, "data": {"req_head":<heading>, "req_depth":<depth>, "manipulator":{manipulator data}}}


!*!*!* Info from this line down is preliminary architecture conceptual work *!*!*!


*** Surface -> ROV Comms ***
command - param1: type, param2: type
	setHeading - heading: number
	setDepth - depth: number
	setThruster - thruster: number, power: number (percentage, -100 to +100)
	heartbeat - id: number (randomly generated, unique for every heartbeat.
							This allows the surface to make sure the ROV is 
							responding to the latest heartbeat request.)
		
*** ROV -> Surface Comms ***
sensor id - type
	id - number (echo the heartbeat ID sent by the surface)
	depth - number (pressure sensor adjusted to actual depth in mm)
	temp - number (adjusted to Â°C)
	head - number
